import itertools
from common import \
    ERR_DECODE, \
    ERR_INPUT, \
    TEST_VECTOR, \
    Bytes, \
    Unsigned, \
    Vec, \
    format_dst, \
    gen_rand, \
    vec_add, \
    vec_neg, \
    vec_sub, \
    xor
from field import Field2
import field
from prg import PrgFixedKeyAes128


class Idpf:
    """An Incremental Distributed Point Function (IDPF)."""

    # Number of keys generated by the IDPF-key generation algorithm.
    SHARES = 2

    # Bit length of valid input values (i.e., the length of `alpha` in bits).
    BITS = 16

    # The length of each output vector (i.e., the length of `beta_leaf` and each
    # element of `beta_inner`).
    VALUE_LEN = 2

    # Size in bytes of each IDPF key share.
    KEY_SIZE = PrgFixedKeyAes128.SEED_SIZE

    # Number of random bytes consumed by the `gen()` algorithm.
    RAND_SIZE = 2 * PrgFixedKeyAes128.SEED_SIZE

    # The finite field used to represent the inner nodes of the IDPF tree.
    FieldInner = field.Field64

    # The finite field used to represent the leaf nodes of the IDPF tree.
    FieldLeaf = field.Field255

    @classmethod
    def gen(self, alpha, beta_inner, beta_leaf, binder, rand):
        if alpha >= 2^self.BITS:
            raise ERR_INPUT # alpha too long
        if len(beta_inner) != self.BITS - 1:
            raise ERR_INPUT # beta_inner vector is the wrong size
        if len(rand) != self.RAND_SIZE:
            raise ERR_INPUT # unexpected length for random input

        init_seed = [
            rand[:PrgFixedKeyAes128.SEED_SIZE],
            rand[PrgFixedKeyAes128.SEED_SIZE:],
        ]

        seed = init_seed.copy()
        ctrl = [Field2(0), Field2(1)]
        correction_words = []
        for level in range(self.BITS):
            Field = self.current_field(level)
            keep = (alpha >> (self.BITS - level - 1)) & 1
            lose = 1 - keep
            bit = Field2(keep)

            (s0, t0) = self.extend(seed[0], binder)
            (s1, t1) = self.extend(seed[1], binder)
            seed_cw = xor(s0[lose], s1[lose])
            ctrl_cw = (
                t0[0] + t1[0] + bit + Field2(1),
                t0[1] + t1[1] + bit,
            )

            x0 = xor(s0[keep], ctrl[0].conditional_select(seed_cw))
            x1 = xor(s1[keep], ctrl[1].conditional_select(seed_cw))
            (seed[0], w0) = self.convert(level, x0, binder)
            (seed[1], w1) = self.convert(level, x1, binder)
            ctrl[0] = t0[keep] + ctrl[0] * ctrl_cw[keep]
            ctrl[1] = t1[keep] + ctrl[1] * ctrl_cw[keep]

            b = beta_inner[level] if level < self.BITS-1 else beta_leaf
            if len(b) != self.VALUE_LEN:
                raise ERR_INPUT # beta too long or too short

            w_cw = vec_add(vec_sub(b, w0), w1)
            # Implementation note: Here we negate the correction word if
            # the control bit `ctrl[1]` is set. We avoid branching on the
            # value in order to reduce leakage via timing side channels.
            mask = Field(1) - Field(2) * Field(ctrl[1].as_unsigned())
            for i in range(len(w_cw)):
                w_cw[i] *= mask

            correction_words.append((seed_cw, ctrl_cw, w_cw))

        public_share = self.encode_public_share(correction_words)
        return (public_share, init_seed)

    @classmethod
    def eval(self, agg_id, public_share, init_seed, level, prefixes, binder):
        if agg_id >= self.SHARES:
            raise ERR_INPUT # invalid aggregator ID
        if level >= self.BITS:
            raise ERR_INPUT # level too deep
        if len(set(prefixes)) != len(prefixes):
            raise ERR_INPUT # candidate prefixes are non-unique

        correction_words = self.decode_public_share(public_share)
        out_share = []
        for prefix in prefixes:
            if prefix >= 2^(level+1):
                raise ERR_INPUT # prefix too long

            # The Aggregator's output share is the value of a node of
            # the IDPF tree at the given `level`. The node's value is
            # computed by traversing the path defined by the candidate
            # `prefix`. Each node in the tree is represented by a seed
            # (`seed`) and a set of control bits (`ctrl`).
            seed = init_seed
            ctrl = Field2(agg_id)
            for current_level in range(level+1):
                bit = (prefix >> (level - current_level)) & 1

                # Implementation note: Typically the current round of
                # candidate prefixes would have been derived from
                # aggregate results computed during previous rounds. For
                # example, when using `idpf` to compute heavy
                # hitters, a string whose hit count exceeded the given
                # threshold in the last round would be the prefix of each
                # `prefix` in the current round. (See [BBCGGI21,
                # Section 5.1].) In this case, part of the path would
                # have already been traversed.
                #
                # Re-computing nodes along previously traversed paths is
                # wasteful. Implementations can eliminate this added
                # complexity by caching nodes (i.e., `(seed, ctrl)`
                # pairs) output by previous calls to `eval_next()`.
                (seed, ctrl, y) = self.eval_next(
                    seed,
                    ctrl,
                    correction_words[current_level],
                    current_level,
                    bit,
                    binder,
                )
            out_share.append(y if agg_id == 0 else vec_neg(y))
        return out_share

    @classmethod
    def eval_next(self, prev_seed, prev_ctrl,
                  correction_word, level, bit, binder):
        """
        Compute the next node in the IDPF tree along the path determined by
        a candidate prefix. The next node is determined by `bit`, the bit of
        the prefix corresponding to the next level of the tree.
        """

        Field = self.current_field(level)
        (seed_cw, ctrl_cw, w_cw) = correction_word
        (s, t) = self.extend(prev_seed, binder)
        s[0] = xor(s[0], prev_ctrl.conditional_select(seed_cw))
        s[1] = xor(s[1], prev_ctrl.conditional_select(seed_cw))
        t[0] += ctrl_cw[0] * prev_ctrl
        t[1] += ctrl_cw[1] * prev_ctrl

        next_ctrl = t[bit]
        (next_seed, y) = self.convert(level, s[bit], binder)
        # Implementation note: Here we add the correction word to the
        # output if `next_ctrl` is set. We avoid branching on the value of
        # the control bit in order to reduce side channel leakage.
        mask = Field(next_ctrl.as_unsigned())
        for i in range(len(y)):
            y[i] += w_cw[i] * mask

        return (next_seed, next_ctrl, y)

    @classmethod
    def current_field(self, level):
        return self.FieldInner if level < self.BITS-1 \
                    else self.FieldLeaf

    @classmethod
    def is_prefix(self, x, y, L):
        """Returns `True` iff `x` is the prefix of `y` of length `L`."""
        assert 0 < L and L <= self.BITS
        return y >> (self.BITS - L) == x

    @classmethod
    def extend(self, seed, binder):
        prg = PrgFixedKeyAes128(seed, format_dst(1, 0, 0), binder)
        s = [
            prg.next(PrgFixedKeyAes128.SEED_SIZE),
            prg.next(PrgFixedKeyAes128.SEED_SIZE),
        ]
        b = prg.next(1)[0]
        t = [Field2(b & 1), Field2((b >> 1) & 1)]
        return (s, t)

    @classmethod
    def convert(self, level, seed, binder):
        prg = PrgFixedKeyAes128(seed, format_dst(1, 0, 1), binder)
        next_seed = prg.next(PrgFixedKeyAes128.SEED_SIZE)
        Field = self.current_field(level)
        w = prg.next_vec(Field, self.VALUE_LEN)
        return (next_seed, w)

    @classmethod
    def encode_public_share(self, correction_words):
        encoded = Bytes()
        control_bits = list(itertools.chain.from_iterable(
            cw[1] for cw in correction_words
        ))
        encoded += pack_bits(control_bits)
        for (level, (seed_cw, _, w_cw)) \
            in enumerate(correction_words):
            Field = self.current_field(level)
            encoded += seed_cw
            encoded += Field.encode_vec(w_cw)
        return encoded

    @classmethod
    def decode_public_share(self, encoded):
        l = floor((2*self.BITS + 7) / 8)
        encoded_ctrl, encoded = encoded[:l], encoded[l:]
        control_bits = unpack_bits(encoded_ctrl, 2 * self.BITS)
        correction_words = []
        for level in range(self.BITS):
            Field = self.current_field(level)
            ctrl_cw = (
                control_bits[level * 2],
                control_bits[level * 2 + 1],
            )
            l = PrgFixedKeyAes128.SEED_SIZE
            seed_cw, encoded = encoded[:l], encoded[l:]
            l = Field.ENCODED_SIZE * self.VALUE_LEN
            encoded_w_cw, encoded = encoded[:l], encoded[l:]
            w_cw = Field.decode_vec(encoded_w_cw)
            correction_words.append((seed_cw, ctrl_cw, w_cw))
        if len(encoded) != 0:
            raise ERR_DECODE
        return correction_words

    @classmethod
    def with_bits(self, bits: Unsigned):
        if bits == 0:
            raise ERR_INPUT # number of bits must be positive
        self.BITS = bits
        return self

    @classmethod
    def with_value_len(self, value_len: Unsigned):
        if value_len == 0:
            raise ERR_INPUT # value length must be positive
        self.VALUE_LEN = value_len
        return self


def pack_bits(bits: Vec[Field2]) -> Bytes:
    byte_len = (len(bits) + 7) // 8
    packed = [int(0)] * byte_len
    for i, bit in enumerate(bits):
        packed[i // 8] |= bit.as_unsigned() << (i % 8)
    return Bytes(packed)


def unpack_bits(packed_bits: Bytes, length: Unsigned) -> Vec[Field2]:
    bits = []
    for i in range(length):
        bits.append(Field2(
            (packed_bits[i // 8] >> (i % 8)) & 1
        ))
    leftover_bits = packed_bits[-1] >> (
        (length + 7) % 8 + 1
    )
    if (length + 7) // 8 != len(packed_bits) or leftover_bits != 0:
        raise ERR_DECODE
    return bits


def test_idpf(idpf, alpha, level, prefixes):
    """
    Generate a set of IDPF keys and evaluate them on the given set of prefix.
    """
    beta_inner = [[idpf.FieldInner(1)] * idpf.VALUE_LEN] * (idpf.BITS-1)
    beta_leaf = [idpf.FieldLeaf(1)] * idpf.VALUE_LEN

    # Generate the IDPF keys.
    rand = gen_rand(idpf.RAND_SIZE)
    binder = b'some nonce'
    (public_share, keys) = idpf.gen(alpha, beta_inner, beta_leaf, binder, rand)

    out = [idpf.current_field(level).zeros(idpf.VALUE_LEN)] * len(prefixes)
    for agg_id in range(idpf.SHARES):
        out_share = idpf.eval(
            agg_id, public_share, keys[agg_id], level, prefixes, binder)
        for i in range(len(prefixes)):
            out[i] = vec_add(out[i], out_share[i])

    for (got, prefix) in zip(out, prefixes):
        if idpf.is_prefix(prefix, alpha, level+1):
            if level < idpf.BITS-1:
                want = beta_inner[level]
            else:
                want = beta_leaf
        else:
            want = idpf.current_field(level).zeros(idpf.VALUE_LEN)

        if got != want:
            print('error: {0:b} {1:b} {2}: got {3}; want {4}'.format(
                alpha, prefix, level, got, want))


def gen_test_vec(idpf, alpha, test_vec_instance):
    beta_inner = []
    for level in range(idpf.BITS-1):
        beta_inner.append([idpf.FieldInner(level)] * idpf.VALUE_LEN)
    beta_leaf = [idpf.FieldLeaf(idpf.BITS-1)] * idpf.VALUE_LEN
    rand = gen_rand(idpf.RAND_SIZE)
    binder = b'some nonce'
    (public_share, keys) = idpf.gen(alpha, beta_inner, beta_leaf, binder, rand)

    printable_beta_inner = [
        [ str(elem.as_unsigned()) for elem in value ] for value in beta_inner
    ]
    printable_beta_leaf = [ str(elem.as_unsigned()) for elem in beta_leaf ]
    printable_keys = [ key.hex() for key in keys ]
    test_vec = {
        'bits': int(idpf.BITS),
        'alpha': str(alpha),
        'beta_inner': printable_beta_inner,
        'beta_leaf': printable_beta_leaf,
        'binder': binder.hex(),
        'public_share': public_share.hex(),
        'keys': printable_keys,
    }

    os.system('mkdir -p test_vec/{:02}'.format(VERSION))
    with open('test_vec/{:02}/{}_{}.json'.format(
        VERSION, idpf.test_vec_name, test_vec_instance), 'w') as f:
        json.dump(test_vec, f, indent=4, sort_keys=True)
        f.write('\n')


def test_idpf_exhaustive(idpf, alpha):
    """Generate a set of IDPF keys and test every possible output."""

    # Generate random outputs with which to program the IDPF.
    beta_inner = []
    for _ in range(idpf.BITS - 1):
        beta_inner.append(idpf.FieldInner.rand_vec(idpf.VALUE_LEN))
    beta_leaf = idpf.FieldLeaf.rand_vec(idpf.VALUE_LEN)

    # Generate the IDPF keys.
    rand = gen_rand(idpf.RAND_SIZE)
    binder = b"some nonce"
    (public_share, keys) = idpf.gen(alpha, beta_inner, beta_leaf, binder, rand)

    # Evaluate the IDPF at every node of the tree.
    for level in range(idpf.BITS):
        prefixes = tuple(range(2 ** level))

        out_shares = []
        for agg_id in range(idpf.SHARES):
            out_shares.append(
                idpf.eval(agg_id, public_share,
                          keys[agg_id], level, prefixes, binder))

        # Check that each set of output shares for each prefix sums up to the
        # correct value.
        for prefix in prefixes:
            got = reduce(lambda x, y: vec_add(x,y),
                map(lambda x: x[prefix], out_shares))

            if idpf.is_prefix(prefix, alpha, level+1):
                if level < idpf.BITS-1:
                    want = beta_inner[level]
                else:
                    want = beta_leaf
            else:
                want = idpf.current_field(level).zeros(idpf.VALUE_LEN)

            if got != want:
                print('error: {0:b} {1:b} {2}: got {3}; want {4}'.format(
                    alpha, prefix, level, got, want))

if __name__ == '__main__':
    idpf = Idpf.with_value_len(2)
    if TEST_VECTOR:
        gen_test_vec(idpf.with_bits(10), 0, 0)

    test_idpf(idpf.with_bits(16), 0b1111000011110000, 15, (0b1111000011110000,))
    test_idpf(idpf.with_bits(16), 0b1111000011110000, 14, (0b111100001111000,))
    test_idpf(idpf.with_bits(16), 0b1111000011110000, 13, (0b11110000111100,))
    test_idpf(idpf.with_bits(16), 0b1111000011110000, 12, (0b1111000011110,))
    test_idpf(idpf.with_bits(16), 0b1111000011110000, 11, (0b111100001111,))
    test_idpf(idpf.with_bits(16), 0b1111000011110000, 10, (0b11110000111,))
    test_idpf(idpf.with_bits(16), 0b1111000011110000, 5, (0b111100,))
    test_idpf(idpf.with_bits(16), 0b1111000011110000, 4, (0b11110,))
    test_idpf(idpf.with_bits(16), 0b1111000011110000, 3, (0b1111,))
    test_idpf(idpf.with_bits(16), 0b1111000011110000, 2, (0b111,))
    test_idpf(idpf.with_bits(16), 0b1111000011110000, 1, (0b11,))
    test_idpf(idpf.with_bits(16), 0b1111000011110000, 0, (0b1,))
    test_idpf(idpf.with_bits(1000), 0, 999, (0,))
    test_idpf_exhaustive(idpf.with_bits(1), 0)
    test_idpf_exhaustive(idpf.with_bits(1), 1)
    test_idpf_exhaustive(idpf.with_bits(8), 91)
